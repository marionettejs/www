<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Marionette.Application : Documentation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/doc-assets/css/bootstrap.css">
        <link rel="stylesheet" href="/doc-assets/css/main.css">
    </head>
    <body>
        <div id="wrapper">
            <div id="content">

<a id="improve" href="#" class="btn btn-default">
  <i class="glyphicon glyphicon-edit">&nbsp;</i>
  Improve this doc
</a>
<a id="source" href="#" class="btn btn-default">
  <i class="glyphicon glyphicon-eye-open">&nbsp;</i>
  View the source
</a>
<h1>Marionette.Application</h1>

<p>The <code>Backbone.Marionette.Application</code> object is the hub of your composite
application. It organizes, initializes and coordinates the various pieces of your
app. It also provides a starting point for you to call into from your HTML
script block, or directly from your JavaScript files if you prefer to go that
route.</p>

<p>The <code>Application</code> is meant to be instantiated directly, although you can extend
it to add your own functionality.</p>

<pre><code class="js">MyApp = new Backbone.Marionette.Application();
</code></pre>

<h2>Documentation Index</h2>

<ul>
<li><a href="#adding-initializers">Adding Initializers</a></li>
<li><a href="#application-event">Application Event</a></li>
<li><a href="#starting-an-application">Starting An Application</a></li>
<li><a href="#the-global-channel">The Global Channel</a>

<ul>
<li><a href="#event-aggregator">Event Aggregator</a></li>
<li><a href="#request-response">Request Response</a></li>
<li><a href="#commands">Commands</a></li>
<li><a href="#accessing-the-global-channel">Accessing the Global Channel</a></li>
</ul></li>
<li><a href="#regions-and-the-application-object">Regions And The Application Object</a>

<ul>
<li><a href="#jquery-selector">jQuery Selector</a></li>
<li><a href="#custom-region-class">Custom Region Class</a></li>
<li><a href="#custom-region-class-and-selector">Custom Region Class And Selector</a></li>
<li><a href="#get-region-by-name">Get Region By Name</a></li>
<li><a href="#removing-regions">Removing Regions</a></li>
</ul></li>
</ul>

<h2>Adding Initializers</h2>

<p>Your application needs to do useful things, like displaying content in your
regions, starting up your routers, and more. To accomplish these tasks and
ensure that your <code>Application</code> is fully configured, you can add initializer
callbacks to the application.</p>

<pre><code class="js">MyApp.addInitializer(function(options){
  // do useful stuff here
  var myView = new MyView({
    model: options.someModel
  });
  MyApp.mainRegion.show(myView);
});

MyApp.addInitializer(function(options){
  new MyAppRouter();
  Backbone.history.start();
});
</code></pre>

<p>These callbacks will be executed when you start your application,
and are bound to the application object as the context for
the callback. In other words, <code>this</code> is the <code>MyApp</code> object inside
of the initializer function.</p>

<p>The <code>options</code> argument is passed from the <code>start</code> method (see below).</p>

<p>Initializer callbacks are guaranteed to run, no matter when you
add them to the app object. If you add them before the app is
started, they will run when the <code>start</code> method is called. If you
add them after the app is started, they will run immediately.</p>

<h2>Application Event</h2>

<p>The <code>Application</code> object raises a few events during its lifecycle, using the
<a href="./marionette.functions.md">Marionette.triggerMethod</a> function. These events
can be used to do additional processing of your application. For example, you
may want to pre-process some data just before initialization happens. Or you may
want to wait until your entire application is initialized to start
<code>Backbone.history</code>.</p>

<p>The events that are currently triggered, are:</p>

<ul>
<li><strong>&quot;before:start&quot; / <code>onBeforeStart</code></strong>: fired just before the <code>Application</code> starts and before the initializers are executed.</li>
<li><strong>&quot;start&quot; / <code>onStart</code></strong>: fires after the <code>Application</code> has started and after the initializers have been executed.</li>
</ul>

<pre><code class="js">MyApp.on(&quot;before:start&quot;, function(options){
  options.moreData = &quot;Yo dawg, I heard you like options so I put some options in your options!&quot;
});

MyApp.on(&quot;start&quot;, function(options){
  if (Backbone.history){
    Backbone.history.start();
  }
});
</code></pre>

<p>The <code>options</code> parameter is passed through the <code>start</code> method of the application
object (see below).</p>

<h2>Starting An Application</h2>

<p>Once you have your application configured, you can kick everything off by
calling: <code>MyApp.start(options)</code>.</p>

<p>This function takes a single optional parameter. This parameter will be passed
to each of your initializer functions, as well as the initialize events. This
allows you to provide extra configuration for various parts of your app throughout the
initialization sequence.</p>

<pre><code class="js">var options = {
  something: &quot;some value&quot;,
  another: &quot;#some-selector&quot;
};

MyApp.start(options);
</code></pre>

<h2>The Global Channel</h2>

<p>Marionette Applications come with a <a href="http://en.wikipedia.org/wiki/Message_passing">messaging system</a> to facilitate communications within your app.</p>

<p>The messaging system on the Application is the global channel from Backbone.Wreqr, which is actually comprised of three distinct systems.</p>

<p>This section will give a brief overview of the systems; for a more in-depth look you are encouraged to read
the <a href="https://github.com/marionettejs/backbone.wreqr"><code>Backbone.Wreqr</code> documentation</a>.</p>

<h3>Event Aggregator</h3>

<p>The Event Aggregator is available through the <code>vent</code> property. <code>vent</code> is convenient for passively sharing information between
pieces of your application as events occur.</p>

<pre><code class="js">MyApp = new Backbone.Marionette.Application();

// Alert the user on the &#39;minutePassed&#39; event
MyApp.vent.on(&quot;minutePassed&quot;, function(someData){
  alert(&quot;Received&quot;, someData);
});

// This will emit an event with the value of window.someData every minute
window.setInterval(function() {
  MyApp.vent.trigger(&quot;minutePassed&quot;, window.someData);
}, 1000 * 60);
</code></pre>

<h3>Request Response</h3>

<p>Request Response is a means for any component to request information from another component without being tightly coupled. An instance of Request Response is available on the Application as the <code>reqres</code> property.</p>

<pre><code class="js">MyApp = new Backbone.Marionette.Application();

// Set up a handler to return a todoList based on type
MyApp.reqres.setHandler(&quot;todoList&quot;, function(type){
  return this.todoLists[type];
});

// Make the request to get the grocery list
var groceryList = MyApp.reqres.request(&quot;todoList&quot;, &quot;groceries&quot;);

// The request method can also be accessed directly from the application object
var groceryList = MyApp.request(&quot;todoList&quot;, &quot;groceries&quot;);
</code></pre>

<h3>Commands</h3>

<p>Commands are used to make any component tell another component to perform an action without a direct reference to it. A Commands instance is available under the <code>commands</code> property of the Application.</p>

<p>Note that the callback of a command is not meant to return a value.</p>

<pre><code class="js">MyApp = new Backbone.Marionette.Application();

MyApp.model = new Backbone.Model();

// Set up the handler to call fetch on the model
MyApp.commands.setHandler(&quot;fetchData&quot;, function(reset){
  MyApp.model.fetch({reset: reset});
});

// Order that the data be fetched
MyApp.commands.execute(&quot;fetchData&quot;, true);

// The execute function is also available directly from the application
MyApp.execute(&quot;fetchData&quot;, true);
</code></pre>

<h3>Accessing the Global Channel</h3>

<p>To access this global channel from other objects within your app you are encouraged to get a handle of the systems
through the Wreqr API instead of the Application instance itself.</p>

<pre><code class="js">// Assuming that we&#39;re in some class within your app,
// it is preferable to access the global channel like this:
var globalCh = Backbone.Wreqr.radio.channel(&#39;global&#39;);
globalCh.vent;

// This is discouraged because it assumes the name of your application
window.app.vent;
</code></pre>

<h2>Regions And The Application Object</h2>

<p>Marionette&#39;s <code>Region</code> objects can be directly added to an application by
calling the <code>addRegions</code> method.</p>

<p>There are three syntax forms for adding a region to an application object.</p>

<h3>jQuery Selector</h3>

<p>The first is to specify a jQuery selector as the value of the region
definition. This will create an instance of a Marionette.Region directly,
and assign it to the selector:</p>

<pre><code class="js">MyApp.addRegions({
  someRegion: &quot;#some-div&quot;,
  anotherRegion: &quot;#another-div&quot;
});
</code></pre>

<h3>Custom Region Class</h3>

<p>The second is to specify a custom region class, where the region class has
already specified a selector:</p>

<pre><code class="js">MyCustomRegion = Marionette.Region.extend({
  el: &quot;#foo&quot;
});

MyApp.addRegions({
  someRegion: MyCustomRegion
});
</code></pre>

<h3>Custom Region Class And Selector</h3>

<p>The third method is to specify a custom region class, and a jQuery selector
for this region instance, using an object literal:</p>

<pre><code class="js">MyCustomRegion = Marionette.Region.extend({});

MyApp.addRegions({

  someRegion: {
    selector: &quot;#foo&quot;,
    regionClass: MyCustomRegion
  },

  anotherRegion: {
    selector: &quot;#bar&quot;,
    regionClass: MyCustomRegion
  }

});
</code></pre>

<h3>Get Region By Name</h3>

<p>A region can be retrieved by name, using the <code>getRegion</code> method:</p>

<pre><code class="js">var app = new Marionette.Application();
app.addRegions({ r1: &quot;#region1&quot; });

// r1 === r1Again; true
var r1 = app.getRegion(&quot;r1&quot;);
var r1Again = app.r1;
</code></pre>

<p>Accessing a region by named attribute is equivalent to accessing
it from the <code>getRegion</code> method.</p>

<h3>Removing Regions</h3>

<p>Regions can also be removed with the <code>removeRegion</code> method, passing in
the name of the region to remove as a string value:</p>

<pre><code class="js">MyApp.removeRegion(&#39;someRegion&#39;);
</code></pre>

<p>Removing a region will properly empty it before removing it from the
application object.</p>

<p>For more information on regions, see <a href="./marionette.region.md">the region documentation</a></p>

            </div>
        </div>
        <script src="/doc-assets/js/lib/jquery.js"></script>
        <script src="/doc-assets/js/lib/prettify/prettify.js"></script>
        <script src="/doc-assets/js/main.js"></script>
    </body>
</html>

