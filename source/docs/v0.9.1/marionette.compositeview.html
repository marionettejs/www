<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Marionette.CompositeView : Documentation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="assets_/css/shCore.css">
        <link rel="stylesheet" href="assets_/css/shThemeDefault.css">
        <link rel="stylesheet" href="assets_/css/main.css">
    </head>
    <body>
        <div id="wrapper">
            <div id="content">

<h1>Marionette.CompositeView</h1>

<p>A <code>CompositeView</code> extends from <code>CollectionView</code> to be used as a 
composite view for scenarios where it should represent both a 
branch and leaf in a tree structure, or for scenarios where a
collection needs to be rendered within a wrapper template.</p>

<p>For example, if you're rendering a treeview control, you may 
want to render a collection view with a model and template so 
that it will show a parent item with children in the tree.</p>

<p>You can specify a <code>modelView</code> to use for the model. If you don't
specify one, it will default to the <code>Marionette.ItemView</code>.</p>

<pre class="brush:js">

CompositeView = Backbone.Marionette.CompositeView.extend({
  template: "#leaf-branch-template"
});

new CompositeView({
  model: someModel,
  collection: someCollection
});
</pre>

<p>For more examples, see my blog post on 
<a href="http://lostechies.com/derickbailey/2012/04/05/composite-views-tree-structures-tables-and-more/">using the composite view</a></p>

<h2>Table of Contents <a href="#toc" name="toc" class="deep-link">#</a></h2>

<ul>
<li><a href="#Composite Model Template">Composite Model Template</a></li>
<li><a href="#CompositeView's appendHtml">CompositeView's appendHtml</a></li>
<li><a href="#Recursive By Default">Recursive By Default</a></li>
<li><a href="#Model And Collection Rendering">Model And Collection Rendering</a></li>
<li><a href="#Events And Callbacks">Events And Callbacks</a></li>
</ul>

<h2>Composite Model Template <a href="#Composite Model Template" id="Composite Model Template" class="deep-link">#</a></h2>

<p>When a <code>CompositeView</code> is rendered, the <code>model</code> will be rendered
with the <code>template</code> that the view is configured with. You can
override the template by passing it in as a constructor option:</p>

<pre class="brush:js">

new MyComp({
  template: "#some-template"
});
</pre>

<h2>CompositeView's appendHtml <a href="#CompositeView's appendHtml" id="CompositeView's appendHtml" class="deep-link">#</a></h2>

<p>By default the composite view uses the same <code>appendHtml</code> method that the
collection view provides. This means the view will call jQuery's <code>.append</code> 
to move the HTML contents from the item view instance in to the collection
view's <code>el</code>. </p>

<p>This isn't very useful with a composite view, though, and you should
override this to append the HTML to the correct DOM element.</p>

<p>For example, if you are building a table view, and want to append each
item from the collection in to the <code>&lt;tbody&gt;</code> of the table, you might
do this with a template:</p>

<pre class="brush:html">

<script id="row-template" type="text/html">
  <td><%= someData %></td>
  <td><%= moreData %></td>
  <td><%= stuff %></td>
</script>

<script id="table-template" type="text/html">
  <table>
    <thead>
      <tr>
        <th>Some Column</th>
        <th>Another Column</th>
        <th>Still More</th>
      </tr>
    </thead>

    <!-- want to insert collection items, here -->
    <tbody></tbody>

    <tfoot>
      <tr>
        <td colspan="3">some footer information</td>
      </tr>
    </tfoot>
  </table>
</script>
</pre>

<p>and you might do this with the CompositeView, and an ItemView for each
item in the collection:</p>

<pre class="brush:js">

RowView = Backbone.Marionette.ItemView.extend({
  tagName: "tr",
  template: "#row-template"
});

TableView = Backbone.Marionette.CollectionView.extend({
  itemView: RowView,

  template: "#table-template",

  appendHtml: function(collectionView, itemView, index){
    collectionView.$("tbody").append(itemView.el);
  }
});
</pre>

<p>For more information on the parameters of this method, see the
<a href="https://github.com/derickbailey/backbone.marionette/blob/master/docs/marionette.collectionview.md">CollectionView's documentation</a>.</p>

<p>For more examples of how a CompositeView can be used, see <a href="http://lostechies.com/derickbailey/2012/04/05/composite-views-tree-structures-tables-and-more/">my blog post
on composite views</a></p>

<h2>Recursive By Default <a href="#Recursive By Default" id="Recursive By Default" class="deep-link">#</a></h2>

<p>The default rendering mode for a <code>CompositeView</code> assumes a
hierarchical, recursive structure. If you configure a composite
view without specifying an <code>itemView</code>, you'll get the same
composite view type rendered for each item in the collection. If
you need to override this, you can specify a <code>itemView</code> in the
composite view's definition:</p>

<pre class="brush:js">

var ItemView = Backbone.Marionette.ItemView.extend({});

var CompView = Backbone.Marionette.CompositeView.extend({
  itemView: ItemView
});
</pre>

<h2>Model And Collection Rendering <a href="#Model And Collection Rendering" id="Model And Collection Rendering" class="deep-link">#</a></h2>

<p>The model and collection for the composite view will re-render
themselves under the following conditions:</p>

<ul>
<li>When the collection's "reset" event is fired, it will only re-render the collection within the composite, and not the wrapper template</li>
<li>When the collection has a model added to it (the "add" event is fired), it will render that one item to the rendered list</li>
<li>When the collection has a model removed (the "remove" event is fired), it will remove that one item from the rendered list</li>
</ul>

<p>You can also manually re-render either or both of them:</p>

<ul>
<li>If you want to re-render everything, call the <code>.render()</code> method</li>
<li>If you want to re-render the model's view, you can call <code>.renderModel()</code></li>
<li>If you want to re-render the collection's views, you can call <code>.renderCollection()</code></li>
</ul>

<h2>Events And Callbacks <a href="#Events And Callbacks" id="Events And Callbacks" class="deep-link">#</a></h2>

<p>During the course of rendering a composite, several events will
be triggered:</p>

<ul>
<li>"composite:item:rendered" - after the <code>modelView</code> has been rendered</li>
<li>"composite:collection:rendered" - after the collection of models has been rendered</li>
<li>"render" / "composite:rendered" - after everything has been rendered</li>
</ul>

<p>Additionally, after the composite view has been rendered, an 
<code>onRender</code> method will be called. You can implement this in 
your view to provide custom code for dealing with the view's 
<code>el</code> after it has been rendered:</p>

<pre class="brush:js">

Backbone.Marionette.CompositeView.extend({
  onRender: function(){
    // do stuff here
  }
});
</pre>
            </div>
        </div>
        <script src="assets_/js/lib/jquery.js"></script>
        <script src="assets_/js/lib/syntax-highlighter/shCore.js"></script>
        <script src="assets_/js/lib/syntax-highlighter/shAutoloader.js"></script>
        <script src="assets_/js/main.js"></script>
    </body>
</html>

