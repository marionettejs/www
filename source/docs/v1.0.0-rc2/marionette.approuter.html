<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Marionette.AppRouter : Documentation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/doc-assets/css/bootstrap.css">
        <link rel="stylesheet" href="/doc-assets/css/main.css">
    </head>
    <body>
        <div id="wrapper">
            <div id="content">

<a id="improve" href="#" class="btn btn-default">
  <i class="glyphicon glyphicon-edit">&nbsp;</i>
  Improve this doc
</a>
<a id="source" href="#" class="btn btn-default">
  <i class="glyphicon glyphicon-eye-open">&nbsp;</i>
  View the source
</a>
<h1>Marionette.AppRouter</h1>

<p>Reduce the boilerplate code of handling route events and then calling a single method on another object.
Have your routers configured to call the method on your object, directly.</p>

<h2>Documentation Index</h2>

<ul>
<li><a href="#configure-routes">Configure Routes</a></li>
<li><a href="#specify-a-controller">Specify A Controller</a></li>
</ul>

<h2>Configure Routes</h2>

<p>Configure an AppRouter with <code>appRoutes</code>. The route definition is passed on to Backbone&#39;s standard routing
handlers. This means that you define routes like you normally would. Instead of providing a callback
method that exists on the router, though, you provide a callback method that exists on the <code>controller</code>
that you specify for the router instance (see below).</p>

<pre><code class="js">MyRouter = Backbone.Marionette.AppRouter.extend({
  // &quot;someMethod&quot; must exist at controller.someMethod
  appRoutes: {
    &quot;some/route&quot;: &quot;someMethod&quot;
  },

  /* standard routes can be mixed with appRoutes/Controllers above */
  routes : {
    &quot;some/otherRoute&quot; : &quot;someOtherMethod&quot;
  },
  someOtherMethod : function(){
    // do something here.
  }

});
</code></pre>

<p>You can also add standard routes to an AppRouter, with methods on the router.</p>

<h2>Specify A Controller</h2>

<p>App routers can only use one <code>controller</code> object. You can either specify this
directly in the router definition:</p>

<pre><code class="js">someController = {
  someMethod: function(){ /*...*/ }
};

Backbone.Marionette.AppRouter.extend({
  controller: someController
});
</code></pre>

<p>Or in a parameter to the constructor:</p>

<pre><code class="js">myObj = {
  someMethod: function(){ /*...*/ }
};

new MyRouter({
  controller: myObj
});
</code></pre>

<p>Or</p>

<p>The object that is used as the <code>controller</code> has no requirements, other than it will 
contain the methods that you specified in the <code>appRoutes</code>.</p>

<p>It is recommended that you divide your controller objects into smaller pieces of related functionality
and have multiple routers / controllers, instead of just one giant router and controller.</p>

            </div>
        </div>
        <script src="/doc-assets/js/lib/jquery.js"></script>
        <script src="/doc-assets/js/lib/prettify/prettify.js"></script>
        <script src="/doc-assets/js/main.js"></script>
    </body>
</html>

