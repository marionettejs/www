<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Marionette.Behavior : Documentation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="assets_/css/shCore.css">
        <link rel="stylesheet" href="assets_/css/shThemeDefault.css">
        <link rel="stylesheet" href="assets_/css/main.css">
    </head>
    <body>
        <div id="wrapper">
            <div id="content">

<h1>Marionette.Behavior</h1>

<p>A <code>Behavior</code> is an  isolated set of DOM / user interactions that can be mixed into any <code>View</code>. <code>Behaviors</code> allow you to blackbox <code>View</code> specific interactions into portable logical chunks, keeping your <code>views</code> simple and your code DRY.</p>

<h2>Table of Contents <a href="#toc" name="toc" class="deep-link">#</a></h2>

<ul>
<li><a href="#Documentation Index">Documentation Index</a></li>
<li><a href="#The Motivation">The Motivation</a></li>
<li><a href="#Using">Using</a></li>
<li><a href="#API">API</a></li>
</ul>

<h2>Documentation Index <a href="#Documentation Index" id="Documentation Index" class="deep-link">#</a></h2>

<ul>
<li><a href="#the-motivation">Motivation</a></li>
<li><a href="#using">Using Behaviors</a></li>
<li><a href="#api">API</a>
<ul><li><a href="#the-event-proxy">Event proxy</a></li>
<li><a href="#model-events">Model Events</a></li>
<li><a href="#model-events">Collection Events</a></li>
<li><a href="#$">$</a></li>
<li><a href="#$el">$el</a></li>
<li><a href="#defaults">Defaults</a></li>
<li><a href="#view">View</a></li></ul></li>
</ul>

<h2>The Motivation <a href="#The Motivation" id="The Motivation" class="deep-link">#</a></h2>

<p>As you build more and more complex views, you will find that your <code>view</code> becomes less about displaying model data, and more about interactions.</p>

<p>These interactions tend to be chunks of logic that you want to use in multiple views.</p>

<h2>Using <a href="#Using" id="Using" class="deep-link">#</a></h2>

<p>Here is an example of a simple <code>itemView</code>. Let's take a stab at simplifying it, and abstracting behaviors from it.</p>

<pre class="brush:js">

var MyView = Marionette.ItemView.extend({
  ui: {
    "close": ".close-btn"
  },

  events: {
    "click @ui.close": "warnBeforeClose"
  },

  warnBeforeClose: function() {
    alert("you are closing all your data is now gone!");
    this.close();
  },

  onShow: function() {
    this.ui.close.tooltip({
      text: "what a nice mouse you have"
    });
  }
});
</pre>

<p>Interaction points, such as tooltips and warning messages, are generic concepts. There is no need to recode them within your views. They are prime for abstraction into a higher level non-coupled concept, which is exactly what Behaviors provide you with.</p>

<p>Here is the syntax for declaring which behaviors get used within a view.
The keys in the hash are passed to <code>getBehaviorClass</code> to lookup the correct <code>Behavior</code> class.
The options for each behavior are also passed to said Behavior during initialization. The options are then stored within each behavior under <code>options</code>.</p>

<pre class="brush:js">

var MyView = Marionette.ItemView.extend({
  ui: {
    "close": ".close-btn"
  },

  behaviors: {
    CloseWarn: {
      message: "you are closing all your data is now gone!"
    },
    ToolTip: {
      text: "what a nice mouse you have"
    }
  }
});
</pre>

<p>Now let's create the <code>CloseWarn</code> behavior.</p>

<pre class="brush:js">

var CloseWarn = Marionette.Behavior.extend({
  // you can set default options
  // just like you can in your Backbone Models
  // they will be overriden if you pass in an option with the same key
  defaults: {
    "message": "you are closing!"
  },

  // behaviors have events that are bound to the views DOM
  events: {
    "click @ui.close": "warnBeforeClose"
  },

  warnBeforeClose: function() {
    alert(this.options.message);
    // every Behavior has a hook into the
    // view that it is attached to
    this.view.close();
  }
});
</pre>

<p>And onto the <code>Tooltip</code> behavior.</p>

<pre class="brush:js">

var ToolTip = Marionette.Behavior.extend({
  ui: {
    tooltip: '.tooltip'
  },

  onShow: function() {
    this.ui.tooltip.tooltip({
      text: this.options.text
    });
  }
});
</pre>

<p>Finally, the user must define a location for where their <code>behaviors</code> are stored.
A simple example of this would look like this:</p>

<pre class="brush:js">

  Marionette.Behaviors.behaviorsLookup = function() {
      return window.Behaviors;
  }
</pre>

<p>In this example you would then store your behaviors like this:</p>

<pre class="brush:js">

window.Behaviors.ToolTip = ToolTip;
window.Behaviors.CloseWarn = CloseWarn;
</pre>

<h2>API <a href="#API" id="API" class="deep-link">#</a></h2>

<h3>the event proxy</h3>

<p>Behaviors are powered by an event proxy. What this means is that any events that are triggered by the view's <code>triggerMethod</code> function are passed to each Behavior on the view as well.</p>

<p>As a real world example, whenever in your <code>view</code> you would have <code>onShow</code>, your behavior can also have this <code>onShow</code> method defined. The same follows for <code>modelEvents</code> and <code>collectionEvents</code>. Think of your behavior as a receiver for all of the events on your view instance.</p>

<p>This concept also allows for a nice decoupled method to communicate to behaviors from your view instance.
You can just call from within your view <code>this.triggerMethod("SomeEvent", {some: "data"})</code>. then your <code>behavior</code> class would look like this:</p>

<pre class="brush:js">

Marionette.Behavior.extend({
    onSomeEvent: function(data) {
        console.log("wow such data", data);
    }
});
</pre>

<h3>Model Events</h3>

<p><code>modelEvents</code> will respond to the view's model events.</p>

<pre class="brush:js">

  Marionette.Behavior.extend({
    modelEvents: {
      "change:doge": "onDogeChange"
    },

    onDogeChange: function() {
      // buy more doge...
    }
  });
</pre>

<h3>Collection Events</h3>

<p><code>collectionEvents</code> will respond to the view's collection events.</p>

<pre class="brush:js">

  Marionette.Behavior.extend({
    collectionEvents: {
      add: "onCollectionAdd"
    },

    onCollectionAdd: function() {
    }
  });
</pre>

<h3>$</h3>

<p><code>$</code> is a direct proxy of the views <code>$</code> lookup method.</p>

<pre class="brush:js">

    Marionette.Behavior.extend({
        onShow: function() {
            this.$('.zerg')
        }
    });
</pre>

<h3>$el</h3>

<p><code>$el</code> is a direct proxy of the views <code>el</code> cached as a jquery selector.</p>

<pre class="brush:js">

Marionette.Behavior.extend({
    onShow: function() {
        this.$el.fadeOut('slow')
    }
});
</pre>

<h3>defaults</h3>

<p><code>defaults</code> can be a <code>hash</code> or <code>function</code> to define the default options for your behavior.
The default options will be overridden depending on what you set as the options per behavior (this works just like a <code>backbone.model</code>).</p>

<pre class="brush:js">

Marionette.Behavior.extend({
    defaults: function() {
        return {
            'deepSpace': 9
        }
    }
});
</pre>

<pre class="brush:js">

Marionette.Behavior.extend({
    defaults: {
            'dominion': 'invasion',
            'doge': 'amaze'
    }
});
</pre>

<h3>view</h3>

<p>The <code>view</code> is a reference to the view instance that the <code>behavior</code> is on.</p>

<pre class="brush:js">

Marionette.Behavior.extend({
    onShow: function() {
        this.view.close();
    }
});
</pre>
            </div>
        </div>
        <script src="assets_/js/lib/jquery.js"></script>
        <script src="assets_/js/lib/syntax-highlighter/shCore.js"></script>
        <script src="assets_/js/lib/syntax-highlighter/shAutoloader.js"></script>
        <script src="assets_/js/main.js"></script>
    </body>
</html>

